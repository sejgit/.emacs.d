#+TITLE: init-org.org
#+AUTHOR: SeJ
#+DATE: <2019-11-03 Sun>
#+STARTUP: content latexpreview logdone hidestars hideblocks

#+COMMENTARY: My attempt at an ORG tangled init file.
#+LOG: Update Log
- <2019-10-29 Tue> Init SeJ
- <2019-11-01 Fri> init-bindings.el tangled

* constants
  #+BEGIN_SRC emacs-lisp
    (defconst sej-homepage
      "https://github.com/sejgit/.emacs.d"
      "The Github page of SeJ Emacs.")

    (defconst sys/win32p
      (eq system-type 'windows-nt)
      "Are we running on a WinTel system?")

    (defconst sys/linuxp
      (eq system-type 'gnu/linux)
      "Are we running on a GNU/Linux system?")

    (defconst sys/macp
      (eq system-type 'darwin)
      "Are we running on a Mac system?")

    (defconst sys/mac-x-p
      (and (display-graphic-p) sys/macp)
      "Are we running under X on a Mac system?")

    (defconst sys/linux-x-p
      (and (display-graphic-p) sys/linuxp)
      "Are we running under X on a GNU/Linux system?")

    (defconst sys/cygwinp
      (eq system-type 'cygwin)
      "Are we running on a Cygwin system?")

    (defconst sys/rootp
      (string-equal "root" (getenv "USER"))
      "Are you using ROOT user?")

    (defconst emacs/>=25p
      (>= emacs-major-version 25)
      "Emacs is 25 or above.")

    (defconst emacs/>=26p
      (>= emacs-major-version 26)
      "Emacs is 26 or above.")

    (defconst emacs/>=27p
      (>= emacs-major-version 27)
      "Emacs is 27 or above.")

    (defconst emacs/>=25.2p
      (or emacs/>=26p
          (and (= emacs-major-version 25) (>= emacs-minor-version 2)))
      "Emacs is 25.2 or above.")
  #+END_SRC

* customization
  #+BEGIN_SRC emacs-lisp
    (defgroup sej nil
      "SeJ Emacs customizations."
      :group 'convenience)

    (defcustom sej-full-name "Stephen Jenkins"
      "Set user full name."
      :type 'string)

    (defcustom sej-mail-address "stephenearljenkins@gmail.com"
      "Set user email address."
      :type 'string)

    (defcustom sej-proxy "localhost:80"
      "Set network proxy."
      :type 'string)

    (defcustom sej-theme 'default
      "Set color theme."
      :type '(choice
              (const :tag "Default theme" default)
              (const :tag "Classic theme" classic)
              (const :tag "Doom theme" doom)
              (const :tag "Dark theme" dark)
              (const :tag "Light theme" light)
              (const :tag "Daylight theme" daylight)
              symbol))

    (defcustom sej-dashboard t
      "Use dashboard at startup or not.
    If Non-nil, use dashboard, otherwise will restore previous session."
      :type 'boolean)

    (defcustom sej-lsp 'lsp-mode
      "Set language server."
      :type '(choice
              (const :tag "LSP Mode" 'lsp-mode)
              (const :tag "eglot" 'eglot)
              nil))

    (defcustom sej-benchmark nil
      "Enable the init benchmark or not."
      :type 'boolean)

    (defcustom sej-org-directory "~/gdrive/todo"
      "Set org directory"
      :type 'string)

    (defcustom sej-project-org-capture-text "Project"
      "Text for the Label for the Org Capture Project journal"
      :type 'string)

    (defcustom sej-project-org-capture-file "~/exampleproject/journal.org"
      "Filename for the Org Capture Project Journal"
      :type 'string)

    (defcustom sej-latex-directory "~/AppData/Local/Programs/MiKTeX 2.9/miktex/bin/x64/"
      "Directory for Latex"
      :type 'string)

    ;; Load `custom-file'
    ;; If it doesn't exist, copy from the template, then load it.
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

    (let ((custom-template-file
           (expand-file-name "custom-template.el" user-emacs-directory)))
      (if (and (file-exists-p custom-template-file)
               (not (file-exists-p custom-file)))
          (copy-file custom-template-file custom-file)))

    (if (file-exists-p custom-file)
        (load custom-file))

    ;; Load `custom-post.el'
    ;; Put personal configurations to override defaults here.
    ;; place to hold specific & secret stuff ~/.ssh is best
    (add-hook 'after-init-hook
              (progn
                (let ((file
                       (expand-file-name "custom-post.el" user-emacs-directory)))
                  (if (file-exists-p file)
                      (load file)))
                (let ((file
                       (expand-file-name "custom-post.el" "~/.ssh/")))
                  (if (file-exists-p file)
                      (load file)))
                ))
  #+END_SRC

* initialize basic
** environment general
   #+BEGIN_SRC emacs-lisp
     ;; Load path
     ;; Optimize: Force "lisp"" and "site-lisp" at the head to reduce the startup time.
     (defun update-load-path (&rest _)
       "Update `load-path'."
       (push (expand-file-name "site-lisp" user-emacs-directory) load-path)
       (push (expand-file-name "lisp" user-emacs-directory) load-path))

     (defun add-subdirs-to-load-path (&rest _)
       "Add subdirectories to `load-path'."
       (let ((default-directory
               (expand-file-name "site-lisp" user-emacs-directory)))
         (normal-top-level-add-subdirs-to-load-path)))

     (advice-add #'package-initialize :after #'update-load-path)
     (advice-add #'package-initialize :after #'add-subdirs-to-load-path)

     (update-load-path)

     ;; turn on syntax highlightng for all buffers
     (global-font-lock-mode t)

     ;; raise the maximum number of logs in the *Messages* buffer
     (setq message-log-max 16384)

     ;; wait a bit longer than the default 0.5s before assuming Emacs is idle
     (setq idle-update-delay 2)

     ;; make gnutls a bit safer
     (setq gnutls-min-prime-bits 4096)

     ;; remove irritating 'got redefined' messages
     (setq ad-redefinition-action 'accept)

     ;; figure out current hostname
     (setq hostname (replace-regexp-in-string "\\(^[[:space:]\n]*\\|[[:space:]\n]*$\\)" "" (with-output-to-string (call-process "hostname" nil standard-output))))

     ;; allow exit without asking to kill processes
     (setq confirm-kill-processes nil)
   #+END_SRC

** initialize package system
*** Custom file hack
    - HACK: DO NOT copy package-selected-packages to init/custom file forcibly.
      https://github.com/jwiegley/use-package/issues/383#issuecomment-247801751
    #+BEGIN_SRC emacs-lisp
      (defun my-save-selected-packages (&optional value)
        "Set `package-selected-packages' to VALUE but don't save to `custom-file'."
        (when value
          (setq package-selected-packages value)))
      (advice-add 'package--save-selected-packages :override #'my-save-selected-packages)
    #+END_SRC

*** Package set-up
    #+BEGIN_SRC emacs-lisp
      (require 'package)
      (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
      (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/") t)
      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

      (setq load-prefer-newer t)

      ;; Initialize packages
      (unless (bound-and-true-p package--initialized) ; To avoid warnings in 27
        (setq package-enable-at-startup nil)          ; To prevent initializing twice
        (package-initialize))
    #+END_SRC

*** Use-Package set-up
    #+BEGIN_SRC emacs-lisp
      ;; Setup `use-package'
      (unless (package-installed-p 'use-package)
        (package-refresh-contents)
        (package-install 'use-package))

      ;; Should set before loading `use-package'
      (eval-and-compile
        (setq use-package-always-ensure t)
        (setq use-package-always-defer t)
        (setq use-package-expand-minimally t)
        (setq use-package-enable-imenu-support t))

      (eval-when-compile
        (require 'use-package))

      ;; Required by `use-package'
      (use-package diminish)
      (use-package bind-key)
    #+END_SRC

*** Begin benchmarking of packages
    #+BEGIN_SRC emacs-lisp
      (use-package benchmark-init
        :demand t
        :config
        (benchmark-init/activate)
        ;; To disable collection of benchmark data after init is done.
        ;;(add-hook 'after-init-hook 'benchmark-init/deactivate)
        )
    #+END_SRC

** environment system specific
   - Set environment variables based on current system & paths
   #+BEGIN_SRC emacs-lisp
     (when sys/win32p
       (setenv "PATH"
               (mapconcat
                #'identity exec-path path-separator))
       ;; set exec-path for latex installation
       (setq exec-path (append (list sej-latex-directory
                                     "c:/msys64/mingw64/bin"
                                     "/mingw64/bin/") exec-path))
       ;; load AutoHotkey mode
       (load-library "xahk-mode"))

     (when (or sys/mac-x-p sys/linux-x-p)
       (use-package exec-path-from-shell
         :init
         (setq exec-path-from-shell-check-startup-files nil)
         (setq exec-path-from-shell-variables
               '("PATH" "MANPATH" "PYTHONPATH" "GOPATH"))
         (setq exec-path-from-shell-arguments '("-l"))
         (exec-path-from-shell-initialize))
       (setq exec-path (append exec-path '("/usr/local/bin"))))

     (setq-default locate-command "which")

     ;; The EMACS environment variable being set to the binary path of emacs.
     (setenv "EMACS"
             (file-truename (expand-file-name
                             invocation-name invocation-directory)))

   #+END_SRC

** sej/after-init-hook
   - to delay some items until after we get going
   #+BEGIN_SRC emacs-lisp
     ;; add my custom hook
     (defvar sej/after-init-hook nil
       "Hook called after emacs-init and some time.")

     (defvar sej/idle-timer 5
       "Var to set time in seconds for idle timer.")
     (when sys/macp
       (setq sej/idle-timer 1))

     (defun sej/run-my-after-init-hook ()
       "Function to define when to run my startup hooks"
       (interactive)
       (message "set-up my hooks")
       (run-with-idle-timer sej/idle-timer nil
                            (lambda ()
                              (message "start running my hooks")
                              (run-hooks 'sej/after-init-hook)
                              (message "done running my hooks")
                              )))

     (add-hook 'after-init-hook 'sej/run-my-after-init-hook)
     ;; (remove-hook 'after-init-hook 'sej/run-my-after-init-hook)
     (add-hook 'emacs-startup-hook 'sej/frame-resize-full)
   #+END_SRC
** start server
   - but wait until sej/after-init
   #+BEGIN_SRC emacs-lisp
     (use-package server
       :ensure nil
       :hook (sej/after-init . server-mode)
       )
   #+END_SRC

* general bindings
** Set OS specific modifiers
*** MAC OS Apple keyboard
    - caps lock is control (through karabiner)
      Fn key do Hyper
      LControl key do RControl (karabiner) which is Super (emacs)
      left opt/alt key do emacs Alt modifier
      right opt/alt key do regular alt key
      left and right command(apple) key do Meta
      karabiner.json backup files in dotfiles under .config directory
    #+BEGIN_SRC emacs-lisp
      (cond
       (sys/macp ; OSX
        (progn
          (message "Mac OSX")
          (if (boundp 'mac-carbon-version-string) ;; using mac-port?
              ( progn
                ;; for emacs-mac-port
                (setq mac-right-command-modifier 'none)
                (setq mac-right-option-modifier 'none)
                (setq mac-function-modifier 'hyper)
                (setq mac-control-modifier 'control)
                (setq mac-right-control-modifier 'super)
                (setq mac-option-modifier 'alt)
                (setq mac-command-modifier 'meta))
            ( progn
              ;; for regular Emacs port
              (setq ns-right-command-modifier 'none)
              (setq ns-right-option-modifier 'none)
              (setq ns-function-modifier 'hyper)
              (setq ns-control-modifier 'control)
              (setq ns-right-control-modifier 'super)
              (setq ns-option-modifier 'alt)
              (setq ns-command-modifier 'meta)
              )))))
    #+END_SRC

*** PC keyboard
    - CapsLock::LControl through AutoHotkeys
      scroll lock do hyper (tab to scroll lock using AutoHotkeys)
      Left control key do super (LControl::Appskey using AutoHotkeys)
      Left Windows left alone due to win10 taking many keys
      LAlt::Meta
      RAlt::Alt modifier (RAlt::NumLock using Autohotkeys) **only works as tap & release
      Rwin is Alt (not used in current laptop)
      NOTE: only negative of this set-up is RAlt as numlock -> Alt is awkward push & release
    #+BEGIN_SRC emacs-lisp
      (cond
       (sys/win32p ; Microsoft Windows
        (progn
          (message "Microsoft Windows")
          (setq w32-pass-lwindow-to-system t
                w32-recognize-altgr nil
                W32-enable-caps-lock nil
                w32-pass-rwindow-to-system nil
                w32-rwindow-modifier 'meta
                w32-apps-modifier 'super
                w32-pass-alt-to-system t
                w32-alt-is-meta t
                w32-scroll-lock-modifier 'hyper
                w32-enable-num-lock nil)
          (w32-register-hot-key [A-])
          (define-key function-key-map (kbd "<kp-numlock>") 'event-apply-alt-modifier)
          )))
    #+END_SRC

*** Linux keyboard
    - nothing set at this moment
    #+BEGIN_SRC emacs-lisp
      (cond
       (sys/linuxp ; linux
        (progn
          (message "Linux")
          ;; load-dir init.d
          )))
    #+END_SRC

** sej-mode & map set-up
   - Below is taken from stackexchange (Emacs)
     Main use is to have my key bindings have the highest priority
   https://github.com/kaushalmodi/.emacs.d/blob/master/elisp/modi-mode.el
   #+BEGIN_SRC emacs-lisp
     (defvar sej-mode-map (make-sparse-keymap)
       "Keymap for 'sej-mode'.")

       ;;;###autoload
     (define-minor-mode sej-mode
       "A minor mode so that my key settings override annoying major modes."
       ;; If init-value is not set to t, this mode does not get enabled in
       ;; `fundamental-mode' buffers even after doing \"(global-my-mode 1)\".
       ;; More info: http://emacs.stackexchange.com/q/16693/115
       :init-value t
       :lighter " sej"
       :keymap sej-mode-map)

       ;;;###autoload
     (define-globalized-minor-mode global-sej-mode sej-mode sej-mode)

     ;; https://github.com/jwiegley/use-package/blob/master/bind-key.el
     ;; The keymaps in `emulation-mode-map-alists' take precedence over
     ;; `minor-mode-map-alist'
     (add-to-list 'emulation-mode-map-alists `((sej-mode . ,sej-mode-map)))

     ;; Turn off the minor mode in the minibuffer
     (defun turn-off-sej-mode ()
       "Turn off sej-mode."
       (sej-mode -1))
     (add-hook 'minibuffer-setup-hook #'turn-off-sej-mode)

     (defmacro bind-to-sej-map (key fn)
       "Bind to KEY (as FN) a function to the `sej-mode-map'.
       USAGE: (bind-to-sej-map \"f\" #'full-screen-center)."
       `(define-key sej-mode-map (kbd ,key) ,fn))

     ;; http://emacs.stackexchange.com/a/12906/115
     (defun unbind-from-sej-map (key)
       "Unbind from KEY the function from the 'sej-mode-map'.
       USAGE: (unbind-from-modi-map \"key f\")."
       (interactive "kUnset key from sej-mode-map: ")
       (define-key sej-mode-map (kbd (key-description key)) nil)
       (message "%s" (format "Unbound %s key from the %s."
                             (propertize (key-description key)
                                         'face 'font-lock-function-name-face)
                             (propertize "sej-mode-map"
                                         'face 'font-lock-function-name-face))))
     ;; Minor mode tutorial: http://nullprogram.com/blog/2013/02/06/
   #+END_SRC

** shorthand for interactive lambdas
   #+BEGIN_SRC emacs-lisp
     (defmacro λ (&rest body)
       "Shorthand for interactive lambdas (BODY)."
       `(lambda ()
          (interactive)
          ,@body))
   #+END_SRC

** keybindings
*** global keybindings
**** general items
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "RET") 'newline-and-indent)

       ;; unset C- and M- digit keys
       (dotimes (n 10)
         (global-unset-key (kbd (format "C-%d" n)))
         (global-unset-key (kbd (format "M-%d" n)))
         )
     #+END_SRC

**** special character definitions
     - Neat bindings for C-x 8 ; put some Alt bindins there for fun as well
     #+BEGIN_SRC emacs-lisp
       (global-set-key (kbd "C-x 8 l") (λ (insert "\u03bb")))
       (global-set-key (kbd "A-L") (λ (insert "\u03bb")))
       (global-set-key (kbd "C-x 8 t m") (λ (insert "™")))
       (global-set-key (kbd "A-T") (λ (insert "™")))
       (global-set-key (kbd "C-x 8 C") (λ (insert "©")))
       (global-set-key (kbd "A-C") (λ (insert "©")))
       (global-set-key (kbd "C-x 8 >") (λ (insert "→")))
       (global-set-key (kbd "A->") (λ (insert "→")))
       (global-set-key (kbd "C-x 8 8") (λ (insert "∞")))
       (global-set-key (kbd "A-8") (λ (insert "∞")))
       (global-set-key (kbd "C-x 8 v") (λ (insert "✓")))
       (global-set-key (kbd "A-V") (λ (insert "✓")))
     #+END_SRC

**** transpose global
     - Transpose stuff with M-t
     #+BEGIN_SRC emacs-lisp
       (global-unset-key (kbd "M-t")) ;; which used to be transpose-words
       (global-set-key (kbd "M-t l") 'transpose-lines)
       (global-set-key (kbd "M-t w") 'transpose-words)
       (global-set-key (kbd "M-t s") 'transpose-sexps)
       (global-set-key (kbd "M-t p") 'transpose-params)
     #+END_SRC

*** sej-mode-map bindings
**** general sej-mode-map bindings
     #+BEGIN_SRC emacs-lisp
       (define-key global-map (kbd "C-h C-h") nil)
       (define-key sej-mode-map (kbd "C-h C-h") nil)

       (define-key sej-mode-map (kbd "M-'") 'next-multiframe-window)
       (define-key sej-mode-map (kbd "C-j") 'newline-and-indent)
       (define-key sej-mode-map (kbd "C-;") 'comment-dwim-2) ; defined in init-misc-packages
       (define-key sej-mode-map (kbd "M-/") 'hippie-expand)
       (define-key sej-mode-map (kbd "M-j") (lambda () (interactive) (join-line -1)))
       (define-key sej-mode-map (kbd "C-s") 'swiper-isearch)

       (define-key sej-mode-map (kbd "C-+") 'text-scale-increase)
       (define-key sej-mode-map (kbd "C--") 'text-scale-decrease)
       (define-key sej-mode-map (kbd "C-x g") 'magit-status)

       ;;added tips from pragmatic emacs
       (define-key sej-mode-map (kbd "C-x k") 'kill-this-buffer)
       (define-key sej-mode-map (kbd "C-x w") 'delete-frame)

       ;; Zap to char
       (define-key sej-mode-map (kbd "M-z") 'zap-to-char)
       (define-key sej-mode-map (kbd "s-z") (lambda (char) (interactive "cZap to char backwards: ") (zap-to-char -1 char))) ;
       (define-key sej-mode-map (kbd "C-M-d") 'backward-kill-word)

       ;;scroll window up/down by one line
       (define-key sej-mode-map (kbd "A-n") (lambda () (interactive) (scroll-up 1)))
       (define-key sej-mode-map (kbd "A-p") (lambda () (interactive) (scroll-down 1)))
       (define-key sej-mode-map (kbd "A-SPC") 'cycle-spacing)

       ;;added tips from steve drunken blog 10 specific ways to improve productivity
       (define-key sej-mode-map (kbd "C-x C-m") 'execute-extended-command)
       (define-key sej-mode-map (kbd "C-c C-m") 'execute-extended-command)

       ;; Align your code in a pretty way.
       (define-key sej-mode-map (kbd "C-x \\") 'align-regexp)

       ;; push and jump to mark functions
       ;; (defined in init-misc-defuns.el)
       (define-key sej-mode-map (kbd "C-`") 'sej/push-mark-no-activate)
       (define-key sej-mode-map (kbd "M-`") 'sej/jump-to-mark)

       ;; function to edit the curent file as root
       ;; (defined in init-misc-defuns.el)
       (define-key sej-mode-map (kbd "C-c C-s") 'sej/sudo-edit)

       ;; number lines with rectangle defined in init-writing.el
       (define-key sej-mode-map (kbd "C-x r N") 'number-rectangle)

       ;; line numbers when using goto-line M-g M-g or M-g g
       ;; (defined in init-misc-defuns.el)
       (global-set-key [remap goto-line] 'goto-line-preview)
     #+END_SRC


**** hyper modifier
     - use hyper (fn on osx) for mode type bindings
     #+BEGIN_SRC emacs-lisp
       (define-key sej-mode-map (kbd "H-a") 'counsel-ag)
       (define-key sej-mode-map (kbd "<f1>") 'org-mode)
       (define-key sej-mode-map (kbd "H-s") 'shell)
       (define-key sej-mode-map (kbd "<f2>") 'shell)
       (define-key sej-mode-map (kbd "H-m") 'menu-bar-mode)

       (define-key sej-mode-map (kbd "H-e") 'eshell)
       (define-key sej-mode-map (kbd "H-f") 'flycheck-list-errors) ;;defined here for ref
       (define-key sej-mode-map (kbd "C-c g") 'google-this) ;; defined here for ref
       (define-key sej-mode-map (kbd "H-g") 'google-this) ;; defined here for ref
       (define-key sej-mode-map (kbd "C-x G") 'gist-list) ;; defined here for ref
       (define-key sej-mode-map (kbd "H-G") 'gist-list) ;; defined here for ref
       (define-key sej-mode-map (kbd "C-x M") 'git-messenger:popup-message) ;; defined here for ref
       (define-key sej-mode-map (kbd "H-m") 'git-messenger:popup-message) ;; defined here for ref

       (define-key sej-mode-map (kbd "C-h SPC") 'helm-all-mark-rings) ;; defined here for ref
       (define-key sej-mode-map (kbd "H-SPC") 'helm-all-mark-rings) ;; defined here for ref


       (if (boundp 'mac-carbon-version-string) ; mac-ports or ns emacs?
           (progn
             (define-key sej-mode-map (kbd "H-h") (lambda () (interactive) (mac-send-action 'hide)))
             (define-key sej-mode-map (kbd "H-H") (lambda () (interactive) (mac-send-action 'hide-other))))
         (progn
           (define-key sej-mode-map (kbd "H-h") 'ns-do-hide-emacs)
           (define-key sej-mode-map (kbd "H-H") 'ns-do-hide-others))
         )
     #+END_SRC

**** super modifier
     - use super for action type stuff
     #+BEGIN_SRC emacs-lisp
       (define-key sej-mode-map (kbd "s-r") 'jump-to-register)
       (define-key sej-mode-map (kbd "s-b") 'ivy-switch-buffer) ;; defined here only
       (define-key sej-mode-map (kbd "s-i") 'emacs-init-time)
       (define-key sej-mode-map (kbd "s-s") 'save-buffer) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-q") 'save-buffers-kill-emacs) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-[") 'flycheck-previous-error) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-]") 'flycheck-next-error) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-f") 'flycheck-list-errors) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-/") 'define-word-at-point) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-|") 'powerthesaurus-lookup-word-dwim) ;; defined here for ref
       (define-key sej-mode-map (kbd "s-w") 'delete-frame)

       (define-key sej-mode-map (kbd "s-0") 'delete-window)
       (define-key sej-mode-map (kbd "s-1") 'delete-other-windows)
       (define-key sej-mode-map (kbd "s-2") 'split-window-vertically)
       (define-key sej-mode-map (kbd "s-3") 'split-window-right)
       (define-key sej-mode-map (kbd "s-4") 'dired-other-frame)
       (define-key sej-mode-map (kbd "s-5") 'make-frame-command)
       (define-key sej-mode-map (kbd "s-6") 'delete-other-frames)
       (define-key sej-mode-map (kbd "s-7") (lambda () (interactive)
                                              (save-excursion
                                                (other-window 1)
                                                (quit-window))))

       ;; wind move built in package (default bindins are S-<cursor>)
       ;;  (windmove-default-keybindings)) ;; Shift + direction
       ;; winner-mode is to undo & redo windows with C-c left and C-c right
       (when (fboundp 'winner-mode)
         (winner-mode t))
       (define-key sej-mode-map (kbd "s-h") 'windmove-left)
       (define-key sej-mode-map (kbd "s-l") 'windmove-right)
       (define-key sej-mode-map (kbd "s-k") 'windmove-up)
       (define-key sej-mode-map (kbd "s-j") 'windmove-down)
       ;; Make windmove work in org-mode:
       ;; (add-hook 'org-shiftup-final-hook 'windmove-up)
       ;; (add-hook 'org-shiftleft-final-hook 'windmove-left)
       ;; (add-hook 'org-shiftdown-final-hook 'windmove-down)
       ;; (add-hook 'org-shiftright-final-hook 'windmove-right)



       ;;init-frame-cmds bindings here for convenience
       (define-key sej-mode-map (kbd "C-c s <up>") 'sej/frame-resize-full)
       (define-key sej-mode-map (kbd "C-c s <left>") 'sej/frame-resize-l)
       (define-key sej-mode-map (kbd "C-c s <S-left>") 'sej/frame-resize-l2)
       (define-key sej-mode-map (kbd "C-c s <right>") 'sej/frame-resize-r)
       (define-key sej-mode-map (kbd "C-c s <S-right>") 'sej/frame-resize-r2)

       (define-key sej-mode-map (kbd "s-<up>") 'sej/frame-resize-full)
       (define-key sej-mode-map (kbd "s-<left>") 'sej/frame-resize-l)
       (define-key sej-mode-map (kbd "s-S-<left>") 'sej/frame-resize-l2)
       (define-key sej-mode-map (kbd "s-<right>") 'sej/frame-resize-r)
       (define-key sej-mode-map (kbd "s-S-<right>") 'sej/frame-resize-r2)

     #+END_SRC

**** File & buffer finding
     #+BEGIN_SRC emacs-lisp
       (define-key sej-mode-map (kbd "C-x M-f") 'counsel-projectile-find-file)
       (define-key sej-mode-map (kbd "C-c y") 'bury-buffer)
       (define-key sej-mode-map (kbd "s-y") 'bury-buffer)
       (define-key sej-mode-map (kbd "C-c r") 'revert-buffer)
       (define-key sej-mode-map (kbd "M-`") 'file-cache-minibuffer-complete)
       (define-key sej-mode-map (kbd "s-n") 'bs-cycle-next) ; buffer cycle next
       (define-key sej-mode-map (kbd "s-p") 'bs-cycle-previous)
       (setq-default bs-default-configuration "all-intern-last")
       (define-key sej-mode-map (kbd "C-c b") 'sej/create-scratch-buffer) ; defined below
       (define-key sej-mode-map (kbd "C-c s s") 'sej/create-scratch-buffer) ; defined below
       (define-key sej-mode-map (kbd "C-c <tab>") 'sej/indent-buffer) ; defined below

       ;; toggle two most recent buffers
       (fset 'quick-switch-buffer [?\C-x ?b return])
       (define-key sej-mode-map (kbd "s-o") 'quick-switch-buffer)
     #+END_SRC

**** lisp
     - some lisp stuff from Getting Started with Emacs Lisp
     #+BEGIN_SRC emacs-lisp
       (define-key sej-mode-map (kbd "<s-return>") 'eval-last-sexp)
       (define-key sej-mode-map (kbd "<H-return>") 'eval-buffer)
       (define-key sej-mode-map (kbd "<A-return>") 'eval-region)
     #+END_SRC

* general defuns
** sej/minibuffer
   - make sure garbage collection does not happen in minibuffer mode
   #+BEGIN_SRC emacs-lisp
     (defun sej/minibuffer-setup-hook ()
       (setq gc-cons-threshold most-positive-fixnum))

     (defun sej/minibuffer-exit-hook ()
       (setq gc-cons-threshold gc-cons-threshold-original))

     (add-hook 'minibuffer-setup-hook #'sej/minibuffer-setup-hook)
     (add-hook 'minibuffer-exit-hook #'sej/minibuffer-exit-hook)
   #+END_SRC

** sej/copy-from-osx, sej/copy-to-osx
   - https://gist.github.com/the-kenny/267162
   #+BEGIN_SRC emacs-lisp
     (when sys/macp
       (defun sej/copy-from-osx ()
         "For copying from osx."
         (shell-command-to-string "pbpaste"))

       (defun sej/paste-to-osx (text &optional push)
         "For copying to osx TEXT with optional PUSH."
         (let ((process-connection-type nil))
           (let ((proc (start-process "pbcopy" "*Messages*" "pbcopy")))
             (process-send-string proc text)
             (process-send-eof proc))))

       (setq interprogram-cut-function 'sej/paste-to-osx)
       (setq interprogram-paste-function 'sej/copy-from-osx))
   #+END_SRC

** sej/sudo-edit
   - function to edit the curent file as root.
     defined as C-x C-r in above bindings
   #+BEGIN_SRC emacs-lisp
     (defun sej/sudo-edit (&optional arg)
       "Edit currently visited file as root.
     With a prefix ARG prompt for a file to visit.
     Will also prompt for a file to visit if current
     buffer is not visiting a file."
       (interactive "P")
       (if (or arg (not buffer-file-name))
           (find-file (concat "/sudo:root@localhost:"
                              (ido-read-file-name "Find file(as root): ")))
         (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))
   #+END_SRC

** sej/create-non-existent-directory
   - Offer to create parent directories if they do not exist
     automatically run after save
     - http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
   #+BEGIN_SRC emacs-lisp
     (defun sej/create-non-existent-directory ()
       "Ask to make directory for file if it does not exist."
       (let ((parent-directory (file-name-directory buffer-file-name)))
         (when (and (not (file-exists-p parent-directory))
                    (y-or-n-p? (format "Directory `%s' does not exist! Create it?" parent-directory)))
           (make-directory parent-directory t))))

     (add-to-list 'find-file-not-found-functions 'sej/create-non-existent-directory)
   #+END_SRC

** sej/save-macro
   - save last macro to init file
   #+BEGIN_SRC emacs-lisp
     (defun sej/save-macro (name)
       "Save a macro.  Take a NAME as argument and save the last defined macro under this name at the end of your init file."
       (interactive "SName of the macro :")
       (kmacro-name-last-macro name)
       (find-file user-init-file)
       (goto-char (point-max))
       (newline)
       (insert-kbd-macro name)
       (newline)
       (switch-to-buffer nil))
   #+END_SRC

** sej/push-mark-no-activate
   - defined above as C-`
   #+BEGIN_SRC emacs-lisp
     (defun sej/push-mark-no-activate ()
       "Pushes `point' to `mark-ring' and does not activate the region.  Equivalent to \\[set-mark-command] when \\[transient-mark-mode] is disabled."
       (interactive)
       (push-mark (point) t nil)
       (message "Pushed mark to ring"))
   #+END_SRC

** sej/exec
   - not key defined
   - executable functions from ohai and modified for my uses
   #+BEGIN_SRC emacs-lisp
     (defun sej/exec (command)
       "Run a shell command and return its output as a string, whitespace trimmed."
       (interactive)
       (s-trim (shell-command-to-string command)))

     (defun sej/exec-with-rc (command &rest args)
       "Run a shell command and return a list containing two values: its return
     code and its whitespace trimmed output."
       (interactive)
       (with-temp-buffer
         (list (apply 'call-process command nil (current-buffer) nil args)
               (s-trim (buffer-string)))))

     (defun sej/is-exec (command)
       "Returns true if `command' is an executable on the system search path."
       (interactive)
       (f-executable? (s-trim (shell-command-to-string (s-concat "which " command)))))

     (defun sej/resolve-exec (command)
       "If `command' is an executable on the system search path, return its absolute path.
     Otherwise, return nil."
       (interactive)
       (-let [path (s-trim (shell-command-to-string (s-concat "which " command)))]
         (when (f-executable? path) path)))

     (defun sej/exec-if-exec (command args)
       "If `command' satisfies `sej/is-exec', run it with `args' and return its
     output as per `sej/exec'. Otherwise, return nil."
       (interactive)
       (when (sej/is-exec command) (sej/exec (s-concat command " " args))))
   #+END_SRC

** update functions
*** sej/update-config
    - helper function to pull latest config from git tracked dir
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/update-config ()
        "Update git tracked Emacs configurations to the latest version."
        (interactive)
        (let ((dir (expand-file-name user-emacs-directory)))
          (if (file-exists-p dir)
              (progn
                (message "Updating Emacs configurations...")
                (cd dir)
                (shell-command "git pull")
                (message "Update finished. Restart Emacs to complete the process."))
            (message "\"%s\" doesn't exist." dir))))
    #+END_SRC

*** sej/update-dotfiles
    - helper function to pull latest dotfiles config from git tracked dir
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/update-dotfiles ()
        "Update the dotfiles to the latest version."
        (interactive)
        (let ((dir (or (getenv "DOTFILES")
                       (expand-file-name "~/dotfiles/"))))
          (if (file-exists-p dir)
              (progn
                (message "Updating dotfiles...")
                (cd dir)
                (shell-command "git pull")
                (message "Update finished."))
            (message "\"%s\" doesn't exist." dir))))
    #+END_SRC

*** sej/update-org
    - helper function to pull latest dotfiles org files from git tracked dir
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/update-org ()
        "Update Org files to the latest version."
        (interactive)
        (let ((dir (expand-file-name "~/org/")))
          (if (file-exists-p dir)
              (progn
                (message "Updating org files...")
                (cd dir)
                (shell-command "git pull")
                (message "Update finished."))
            (message "\"%s\" doesn't exist." dir))))
    #+END_SRC

*** sej/update-all
    - helper function to pull latest files from git tracked dir
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/update-all()
        "Update dotfiles, org files, Emacs confgiurations and packages, ."
        (interactive)
        (sej/update-config)
        (sej/update-dotfiles)
        (sej/update-org))
    #+END_SRC

*** sej/recompile-elpa
    - Recompile packages in elpa directory.
    - Useful if you switch Emacs versions.
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/recompile-elpa ()
        "Recompile packages in elpa directory. Useful if you switch Emacs versions."
        (interactive)
        (if (fboundp 'async-byte-recompile-directory)
            (async-byte-recompile-directory package-user-dir)
          (byte-recompile-directory package-user-dir 0 t)))
    #+END_SRC

*** Sej/recompile-site-lisp
    - Recompile packages in site-lisp directory.
    - Useful if you switch Emacs versions.
    - not bound
    #+BEGIN_SRC emacs-lisp
      ;; Recompile site-lisp directory
      (defun sej/recompile-site-lisp ()
        "Recompile packages in site-lisp directory."
        (interactive)
        (let ((dir (locate-user-emacs-file "site-lisp")))
          (if (fboundp 'async-byte-recompile-directory)
              (async-byte-recompile-directory dir)
            (byte-recompile-directory dir 0 t))))
    #+END_SRC

** network proxy functions
*** sej/proxy-http-show
    - what are the current proxy settings
    - based on the Emacs settings variables
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/proxy-http-show ()
        "Show http/https proxy."
        (interactive)
        (if url-proxy-services
            (message "Current HTTP proxy is \"%s\"" sej-proxy)
          (message "No proxy")))
    #+END_SRC

*** sej/proxy-http-enable
    - enable proxy settings
    - based on Emacs custom settings
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/proxy-http-enable ()
        "Enable http/https proxy."
        (interactive)
        (setq url-proxy-services `(("http" . ,sej-proxy)
                                   ("https" . ,sej-proxy)
                                   ("no_proxy" . "^\\(localhost\\|192.168.*\\|10.*\\)")))
        (setq url-http-proxy-basic-auth-storage sej-url-http-proxy-basic-auth-storage)
        (sej/proxy-http-show))
    #+END_SRC

*** sej/proxy-http-disable
    - disable proxy settings
    - based on Emacs custom settings
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/proxy-http-disable ()
        "Disable http/https proxy."
        (interactive)
        (setq url-proxy-services nil)
        (setq url-http-proxy-basic-auth-storage nil)
        (sej/proxy-http-show))
    #+END_SRC

*** sej/proxy-http-toggle
    - toggle proxy settings
    - based on Emacs custom settings
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/proxy-http-toggle ()
        "Toggle http/https proxy."
        (interactive)
        (if url-proxy-services
            (sej/proxy-http-disable)
          (sej/proxy-http-enable)))
    #+END_SRC

*** sej/proxy-socks-enable
    - enable socks proxy settings
    - based on Emacs custom settings
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defvar socks-noproxy)
      (defvar socks-server)
      (defun sej/proxy-socks-enable ()
        "Enable Socks proxy."
        (interactive)
        (setq url-gateway-method 'socks)
        (setq socks-noproxy '("localhost"))
        (setq socks-server '("Default server" "127.0.0.1" 1086 5))
        (message "Enable socks proxy."))
    #+END_SRC

*** sej/proxy-socks-disable
    - disable socks proxy settings
    - based on Emacs custom settings
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/proxy-socks-disable ()
        "Disable Socks proxy."
        (interactive)
        (setq url-gateway-method 'native)
        (setq socks-noproxy nil)
        (message "Disable socks proxy."))
    #+END_SRC

* ui & edit settings
** themes
*** sej/load-theme
    - functions to set-up menu of standard themes to load
   #+BEGIN_SRC emacs-lisp
     (defvar after-load-theme-hook nil
       "Hook run after a color theme is loaded using `load-theme'.")
     (defun run-after-load-theme-hook (&rest _)
       "Run `after-load-theme-hook'."
       (run-hooks 'after-load-theme-hook))
     (advice-add #'load-theme :after #'run-after-load-theme-hook)

     (defun standardize-theme (theme)
       "Standardize THEME."
       (pcase theme
         ('default 'doom-Iosvkem)
         ('classic 'doom-molokai)
         ('doom 'doom-peacock)
         ('dark 'doom-Iosvkem)
         ('light 'doom-one-light)
         ('daylight 'doom-tomorrow-day)
         (_ theme)))

     (defun sej/load-theme (theme)
       "Set color THEME."
       (interactive
        (list
         (intern (completing-read "Load theme: "
                                  '(default classic dark light daylight)))))
       (let ((theme (standardize-theme theme)))
         (mapc #'disable-theme custom-enabled-themes)
         (load-theme theme t)))
#+END_SRC

*** doom themes
    - load doom-themes package if selected theme is of the doom family
#+BEGIN_SRC emacs-lisp
     (defun is-doom-theme-p (theme)
       "Check whether the THEME is a doom theme. THEME is a symbol."
       (string-prefix-p "doom" (symbol-name (standardize-theme theme))))

     (if (is-doom-theme-p sej-theme)
         (progn
           (use-package doom-themes
             :init (sej/load-theme sej-theme)
             :config
             ;; Enable flashing mode-line on errors
             (doom-themes-visual-bell-config)
             ;; Corrects (and improves) org-mode's native fontification.
             (doom-themes-org-config))

           ;; Make certain buffers grossly incandescent
           (use-package solaire-mode
             :functions persp-load-state-from-file
             :hook (((after-change-major-mode after-revert ediff-prepare-buffer) . turn-on-solaire-mode)
                    (minibuffer-setup . solaire-mode-in-minibuffer)
                    (after-load-theme . solaire-mode-swap-bg))
             :config
             (solaire-mode-swap-bg)
             (advice-add #'persp-load-state-from-file
                         :after #'solaire-mode-restore-persp-mode-buffers)))
       (progn
         (ignore-errors
           (sej/load-theme sej-theme))))
   #+END_SRC

** frames
*** settings frames
   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '("SeJ Emacs - %b"))
     (setq icon-title-format frame-title-format)

     (when sys/mac-x-p
       (use-package ns-auto-titlebar
         :config

         (add-to-list 'default-frame-alist '(ns-appearance . dark))
         (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
         (add-hook 'after-load-theme-hook
                   (lambda ()
                     (let ((bg (frame-parameter nil 'background-mode)))
                       (set-frame-parameter nil 'ns-appearance bg)
                       (setcdr (assq 'ns-appearance default-frame-alist) bg))))
         (ns-auto-titlebar-mode)))
   #+END_SRC
*** fullscreen
   - WORKAROUND: To address blank screen issue with child-frame in fullscreen
   #+BEGIN_SRC emacs-lisp
     (when sys/mac-x-p
       (setq ns-use-native-fullscreen nil))
     (bind-keys ("C-<f11>" . toggle-frame-fullscreen)
                ("C-s-f" . toggle-frame-fullscreen) ; Compatible with macOS
                ("S-s-<return>" . toggle-frame-fullscreen)
                ("M-S-<return>" . toggle-frame-fullscreen))
   #+END_SRC

** buffers
*** sej/dos2unix
    - convert the current buffer to UNIX file format
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/dos2unix ()
        "Convert the current buffer to UNIX file format."
        (interactive)
        (set-buffer-file-coding-system 'undecided-unix nil))
    #+END_SRC

*** sej/unix2dos
    - convert the current buffer to DOS file format
    - not bound
    #+BEGIN_SRC emacs-lisp
      (defun sej/unix2dos ()
        "Convert the current buffer to DOS file format."
        (interactive)
        (set-buffer-file-coding-system 'undecided-dos nil))
    #+END_SRC

*** sej/save-buffer-as-utf8
    - revert a buffer with coding-system and save as utf-8
    #+BEGIN_SRC emacs-lisp
      (defun sej/save-buffer-as-utf8 (coding-system)
        "Revert a buffer with `CODING-SYSTEM' and save as UTF-8."
        (interactive "zCoding system for visited file (default nil):")
        (revert-buffer-with-coding-system coding-system)
        (set-buffer-file-coding-system 'utf-8)
        (save-buffer))
    #+END_SRC

*** sej/revert-this-buffer
    - revert-buffer without asking
      bound to <f5> todo: merge with C-r revert-buffer
    #+BEGIN_SRC emacs-lisp
      (defun sej/revert-this-buffer ()
        "Revert the current buffer."
        (interactive)
        (unless (minibuffer-window-active-p (selected-window))
          (text-scale-increase 0)
          (widen)
          (if (and (fboundp 'fancy-narrow-active-p)
                   (fancy-narrow-active-p))
              (fancy-widen))
          (revert-buffer t t)
          (message "Reverted this buffer.")))
      (bind-key "<f5>" #'sej/revert-this-buffer)
      (if sys/mac-x-p
          (bind-key "s-r" #'sej/revert-this-buffer))
    #+END_SRC

*** sej/browse-homepage
    - Browse my github homepage
      not bound
    #+BEGIN_SRC emacs-lisp
      (defun browse-homepage ()
        "Browse the Github page of SeJ Emacs."
        (interactive)
        (browse-url sejgit-homepage))
    #+END_SRC

*** sej/quit-and-kill-auxiliary-windows
#+BEGIN_SRC emacs-lisp
(defun sej/quit-and-kill-auxiliary-windows ()
  "Kill buffer and its window on quitting"
  (local-set-key (kbd "q") 'kill-buffer-and-window))
(add-hook 'special-mode 'sej/quit-and-kill-auxiliary-windows)
(add-hook 'compilation-mode-hook 'sej/quit-and-kill-auxiliary-windows)
#+END_SRC
*** autorevert
    - Automatically reload files when modified by external program if not modified
    #+BEGIN_SRC emacs-lisp
      (use-package autorevert
        :ensure nil
        :diminish
        :hook (sej/after-init . global-auto-revert-mode))
    #+END_SRC

*** buffer-move
    - buffer-move to swap buffers between windows
#+BEGIN_SRC emacs-lisp
      (use-package buffer-move)
#+END_SRC

*** scratch buffer set-up
    - initial message
    - bury don't kill scratch
    #+BEGIN_SRC emacs-lisp
      (setq initial-scratch-message "")
      (defadvice kill-buffer (around kill-buffer-around-advice activate)
        "Bury the *scratch* buffer, but never kill it."
        (let ((buffer-to-kill (ad-get-arg 0)))
          (if (equal buffer-to-kill "*scratch*")
              (bury-buffer)
            ad-do-it)))
    #+END_SRC

*** sej/create-scratch-buffer
    - as name suggests
      defined as C-c b in above keymappings
    #+BEGIN_SRC emacs-lisp
      (defun sej/create-scratch-buffer nil
        "Create a new scratch buffer to work in (could be *scratch* - *scratchX*)."
        (interactive)
        (let ((n 0)
              bufname)
          (while (progn
                   (setq bufname (concat "*scratch"
                                         (if (= n 0) "" (int-to-string n))
                                         "*"))
                   (setq n (1+ n))
                   (get-buffer bufname)))
          (switch-to-buffer (get-buffer-create bufname))
          (emacs-lisp-mode)
          ))
      (defalias 'create-scratch-buffer 'sej/create-scratch-buffer)
    #+END_SRC
** windows
*** ace-window
    - for selecting a window to switch to
    #+BEGIN_SRC emacs-lisp
      (use-package ace-window
        :bind (:map sej-mode-map
                    ("M-o" . ace-window)
                    ("C-x M-o" . ace-swap-window))
        :config
        (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
    #+END_SRC

** mode-line
   #+BEGIN_SRC emacs-lisp
     (use-package doom-modeline
       :hook (after-init . doom-modeline-mode)
       (after-save . doom-modeline-update-buffer-file-name)
       (after-save . doom-modeline-update-buffer-file-state-icon)
       :init
       (setq doom-modeline-major-mode-color-icon t)
       (setq doom-modeline-github nil)
       (setq doom-modeline-indent-info t)
       (setq doom-modeline-persp-name t))

     (defun mode-line-height ()
       "Get current height of mode-line."
       (- (elt (window-pixel-edges) 3)
          (elt (window-inside-pixel-edges) 3)))

     (use-package hide-mode-line
       :hook (((completion-list-mode
                completion-in-region-mode
                neotree-mode
                treemacs-mode)
               . hide-mode-line-mode)))
   #+END_SRC

** icons
   - NOTE: Must run `M-x all-the-icons-install-fonts' manually on Windows
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons
       :if (display-graphic-p)
       :custom-face
       ;; Reset colors since they are too dark in `doom-themes'
       (all-the-icons-silver ((((background dark)) :foreground "#716E68")
                              (((background light)) :foreground "#716E68")))
       (all-the-icons-lsilver ((((background dark)) :foreground "#B9B6AA")
                               (((background light)) :foreground "#7F7869")))
       (all-the-icons-dsilver ((((background dark)) :foreground "#838484")
                               (((background light)) :foreground "#838484")))
       :init
       (unless (or sys/win32p (member "all-the-icons" (font-family-list)))
         (all-the-icons-install-fonts t))
       :config
       (add-to-list 'all-the-icons-icon-alist
                    '("\\.go$" all-the-icons-fileicon "go" :face all-the-icons-blue))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(go-mode all-the-icons-fileicon "go" :face all-the-icons-blue))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(help-mode all-the-icons-faicon "info-circle" :height 1.1 :v-adjust -0.1 :face all-the-icons-purple))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(Info-mode all-the-icons-faicon "info-circle" :height 1.1 :v-adjust -0.1))
       (add-to-list 'all-the-icons-icon-alist
                    '("NEWS$" all-the-icons-faicon "newspaper-o" :height 0.9 :v-adjust -0.2))
       (add-to-list 'all-the-icons-icon-alist
                    '("Cask\\'" all-the-icons-fileicon "elisp" :height 1.0 :face all-the-icons-blue))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(cask-mode all-the-icons-fileicon "elisp" :height 1.0 :face all-the-icons-blue))
       (add-to-list 'all-the-icons-icon-alist
                    '(".*\\.ipynb\\'" all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-orange))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(ein:notebooklist-mode all-the-icons-faicon "book" :face all-the-icons-orange))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(ein:notebook-mode all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-orange))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(ein:notebook-multilang-mode all-the-icons-fileicon "jupyter" :height 1.2 :face all-the-icons-orange))
       (add-to-list 'all-the-icons-icon-alist
                    '("\\.epub\\'" all-the-icons-faicon "book" :height 1.0 :v-adjust -0.1 :face all-the-icons-green))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(nov-mode all-the-icons-faicon "book" :height 1.0 :v-adjust -0.1 :face all-the-icons-green))
       (add-to-list 'all-the-icons-mode-icon-alist
                    '(gfm-mode  all-the-icons-octicon "markdown" :face all-the-icons-blue)))
   #+END_SRC

** line numbers
   - Show native line numbers if possible, otherwise use linum
   #+BEGIN_SRC emacs-lisp
     (if (fboundp 'display-line-numbers-mode)
         (use-package display-line-numbers
           :ensure nil
           :hook (prog-mode . display-line-numbers-mode))
       (use-package linum-off
         :demand
         :defines linum-format
         :hook (after-init . global-linum-mode)
         :config
         (setq linum-format "%4d ")

         ;; Highlight current line number
         (use-package hlinum
           :defines linum-highlight-in-all-buffersp
           :hook (global-linum-mode . hlinum-activate)
           :custom-face (linum-highlight-face
                         ((t `(
                               :inherit default
                               :background nil
                               :foreground nil
                               ))))
           :init
           (setq linum-highlight-in-all-buffersp t))))

     (use-package goto-line-preview
       :hook ((goto-line-preview-before-hook . (lambda() (display-line-numbers-mode 1)))
              (goto-line-preview-after-hook . (lambda() (display-line-numbers-mode -1))))
       :config
       (global-set-key [remap goto-line] 'goto-line-preview)
       )
   #+END_SRC

** mouse & smooth scroll
   - Scroll one line at a time (less "jumpy" than defaults)
   #+BEGIN_SRC emacs-lisp
     (setq mouse-wheel-scroll-amount '(1 ((shift) . 1)))
     (setq mouse-wheel-progressive-speed nil)
     (setq scroll-step 1
           scroll-margin 0
           scroll-conservatively 100000)
   #+END_SRC

** display time
   #+BEGIN_SRC emacs-lisp
     (use-package time
       :ensure nil
       :unless (display-graphic-p)
       :hook (after-init . display-time-mode)
       :init
       (setq display-time-24hr-format t)
       (setq display-time-day-and-date t))
   #+END_SRC

** suppress GUI features
   #+BEGIN_SRC emacs-lisp
     (setq use-file-dialog nil)
     (setq use-dialog-box nil)
     (setq inhibit-startup-screen t)
     (setq inhibit-startup-echo-area-message t)
   #+END_SRC

** miscellaneous settings
   #+BEGIN_SRC emacs-lisp
     (size-indication-mode 1)
     (blink-cursor-mode -1)
     (setq track-eol t)                      ; Keep cursor at end of lines. Require line-move-visual is nil.
     (setq line-move-visual nil)
     (setq inhibit-compacting-font-caches t) ; Don’t compact font caches during GC.

     ;; Don't open a file in a new frame
     (when (boundp 'ns-pop-up-frames)
       (setq ns-pop-up-frames nil))

     ;; Don't use GTK+ tooltip
     (when (boundp 'x-gtk-use-system-tooltips)
       (setq x-gtk-use-system-tooltips nil))
   #+END_SRC

** indentation
*** indentation settings
    #+BEGIN_SRC emacs-lisp
      (setq-default tab-width 2
                    indent-tabs-mode nil
                    fill-column 80)
      ;; Line and Column
      (setq column-number-mode t)
      (setq line-number-mode t)

      ;; Javascript
      (setq-default js2-basic-offset 2)

      ;; JSON
      (setq-default js-indent-level 2)

      ;; Coffeescript
      (setq coffee-tab-width 2)

      ;; Typescript
      (setq typescript-indent-level 2
            typescript-expr-indent-offset 2)

      ;; Python
      (setq-default py-indent-offset 2)

      ;; XML
      (setq-default nxml-child-indent 2)

      ;; C
      (setq-default c-basic-offset 2)

      ;; HTML etc with web-mode
      (setq-default web-mode-markup-indent-offset 2
                    web-mode-css-indent-offset 2
                    web-mode-code-indent-offset 2
                    web-mode-style-padding 2
                    web-mode-script-padding 2)
    #+END_SRC

*** dtrt-indent
    - automatically set the right indent for other people's files
    #+BEGIN_SRC emacs-lisp
      (use-package dtrt-indent
        :defer 2
        :diminish
        :config
        ;; (setq dtrt-indent-active-mode-line-info "")
        )
    #+END_SRC

*** aggressive-indent
    - Minor mode to aggressively keep your code always indented
    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :diminish
        :hook (after-init . global-aggressive-indent-mode)
        :config
        ;; Disable in some modes
        (dolist (mode '(asm-mode web-mode html-mode css-mode robot-mode go-mode))
          (push mode aggressive-indent-excluded-modes))
        ;; Be slightly less aggressive in C/C++/C#/Java/Go/Swift
        (add-to-list
         'aggressive-indent-dont-indent-if
         '(and (or (derived-mode-p 'c-mode)
                   (derived-mode-p 'c++-mode)
                   (derived-mode-p 'csharp-mode)
                   (derived-mode-p 'java-mode)
                   (derived-mode-p 'go-mode)
                   (derived-mode-p 'swift-mode))
               (null (string-match "\\([;{}]\\|\\b\\(if\\|for\\|while\\)\\b\\)"
                                   (thing-at-point 'line))))))
    #+END_SRC

*** sej/indent-buffer
    - bound to C-c <tab>
    #+BEGIN_SRC emacs-lisp
      (defun sej/indent-buffer ()
        (interactive)
        (indent-region (point-min) (point-max)))
    #+END_SRC

** history packages
*** saveplace
    - wait until sej/after-init
    #+BEGIN_SRC emacs-lisp
      (use-package saveplace
        :ensure nil
        :hook (sej/after-init . save-place-mode)
        )
    #+END_SRC

*** recentf
    - wait until sej/after-init
    #+BEGIN_SRC emacs-lisp
      (use-package recentf
        :ensure nil
        :hook (sej/after-init . recentf-mode)
        :config
        (setq recentf-max-saved-items 200)
        (setq recentf-exclude '((expand-file-name package-user-dir)
                                ".cache"
                                ".cask"
                                ".elfeed"
                                "bookmarks"
                                "cache"
                                "ido.*"
                                "persp-confs"
                                "recentf"
                                "undo-tree-hist"
                                "url"
                                "COMMIT_EDITMSG\\'")))
    #+END_SRC

*** savehist
    - wait until sej/after-init
    #+BEGIN_SRC emacs-lisp
      (use-package savehist
        :ensure nil
        :hook (sej/after-init . savehist-mode)
        :config
        (setq enable-recursive-minibuffers t ; Allow commands in minibuffers
              history-length 1000
              savehist-additional-variables '(mark-ring
                                              global-mark-ring
                                              search-ring
                                              regexp-search-ring
                                              extended-command-history)
              savehist-autosave-interval 300))
    #+END_SRC

** movement
*** crux
    - smart moving to beginning of line or to beginning of text on line
    #+BEGIN_SRC emacs-lisp
      (use-package crux
        :defines sej-mode-map
        :bind (:map sej-mode-map
                    ("C-c o" . crux-open-with)
                    ("C-k" . crux-smart-kill-line)
                    ("C-S-RET" . crux-smart-open-line-above)
                    ([(shift return)] . crux-smart-open-line)
                    ("C-c n" . crux-cleanup-buffer-or-region)
                    ("C-c u" . crux-view-url)
                    ("C-c C-d" . crux-delete-file-and-buffer)
                    ("s-d" . crux-duplicate-current-line-or-region)
                    ("C-c C-k" . crux-duplicate-current-line-or-region)
                    ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
                    ([remap kill-whole-line] . crux-kill-whole-line)
                    ("C-<backspace>" . crux-kill-line-backwards))
        :config
        (crux-with-region-or-buffer indent-region)
        (crux-with-region-or-buffer untabify)
        (crux-with-region-or-line comment-or-uncomment-region)
        (crux-with-region-or-point-to-eol kill-ring-save)
        (crux-reopen-as-root-mode))
    #+END_SRC

*** mwim
    - better than crux for C-e mwim-end
    #+BEGIN_SRC emacs-lisp
      (use-package mwim
        :bind (:map sej-mode-map
                    ("C-a" . mwim-beginning)
                    ("C-e" . mwim-end))) ; better than crux
    #+END_SRC

*** avy
    - Jump to things in Emacs tree-style
#+BEGIN_SRC emacs-lisp
      (use-package avy
        :bind (:map sej-mode-map
                    ("C-'" . avy-goto-char-2)
                    ("C-:" . avy-goto-char)
                    ("M-g f" . avy-goto-line)
                    ("M-g w" . avy-goto-word-1)
                    ;; ("C-<return>" . avy-goto-word-1)
                    ("s-'" . avy-goto-word-0)
                    ("M-g e" . avy-goto-word-0))
        ;; :hook (after-init . avy-setup-default)
        :config (setq avy-background t))
#+END_SRC

*** goto-chg
    - goto the last changes made in buffer
#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :defines sej-mode-map
    :bind ("C-," . goto-last-change))
#+END_SRC

*** beginend
    - smart moves redefining M-< and M-> for some modes
#+BEGIN_SRC emacs-lisp
  (use-package beginend               ; smart M-< & M->
    :defer 2
    :config
    (beginend-global-mode)
    )
#+END_SRC

*** subword
    - Handling capitalized subwords in a nomenclature
#+BEGIN_SRC emacs-lisp
  (use-package subword
    :ensure nil
    :diminish
    :hook ((prog-mode . subword-mode)
           (minibuffer-setup . subword-mode))
    :config
    ;; this makes forward-word & backward-word understand snake & camel case
    (setq c-subword-mode t)
    (global-subword-mode t))
#+END_SRC

*** string inflection
    - underscore -> upcase -> camelcase conversion
    #+BEGIN_SRC emacs-lisp
      (use-package string-inflection
        :bind (:map sej-mode-map
                    ("M-u" . string-inflection-all-cycle)))
#+END_SRC

** regions
*** avy-zap
    - Kill text between the point and the character CHAR
#+BEGIN_SRC emacs-lisp
      (use-package avy-zap
        :bind (:map sej-mode-map
                    ("M-z" . avy-zap-to-char-dwim)
                    ("M-Z" . avy-zap-up-to-char-dwim)))
#+END_SRC

*** delsel
    - Do not delete selection if you insert
    #+BEGIN_SRC emacs-lisp
      (use-package delsel
        :ensure nil
        :config (setq-default delete-selection-mode nil))
    #+END_SRC

*** rect
    - Rectangle
    #+BEGIN_SRC emacs-lisp
      (use-package rect
        :ensure nil)
    #+END_SRC

*** drag-stuff
    - Drag stuff (lines, words, region, etc...) around
#+BEGIN_SRC emacs-lisp
  (use-package drag-stuff
    :diminish
    :bind (:map sej-mode-map
                ("M-<down>" . drag-stuff-down)
                ("H-n" . drag-stuff-down)
                ("M-<up>" . drag-stuff-up)
                ("H-p" . drag-stuff-up))
    ;; :hook (after-init . drag-stuff-global-mode)
    :config
    (add-to-list 'drag-stuff-except-modes 'org-mode)
    ;; (drag-stuff-define-keys)
    )
#+END_SRC

*** expand-region
    - Increase selected region by semantic units
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind (:map sej-mode-map
                ("C-=" . er/expand-region)))
#+END_SRC

*** smart-region
    - Smartly select region, rectangle, multi cursors
#+BEGIN_SRC emacs-lisp
  (use-package smart-region
    :bind ([remap set-mark-command] . smart-region)
    :config (smart-region-on))
#+END_SRC

*** hungary-delete
    - Hungry deletion
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish
    :hook (sej/after-init . global-hungry-delete-mode)
    :config (setq-default hungry-delete-chars-to-skip " \t\f\v"))
#+END_SRC

** search
*** re-builder
    - set built in regex helper to string format
    #+BEGIN_SRC emacs-lisp
      (use-package re-builder
        :ensure nil
        :config (setq reb-re-syntax 'string))
    #+END_SRC

*** anzu
    - Display incremental search stats in the modeline.
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :diminish
    :bind (([remap query-replace] . anzu-query-replace)
           ([remap query-replace-regexp] . anzu-query-replace-regexp)
           :map isearch-mode-map
           ([remap isearch-query-replace] . anzu-isearch-query-replace)
           ([remap isearch-query-replace-regexp] . anzu-isearch-query-replace-regexp))
    :hook (after-init . global-anzu-mode)
    )
#+END_SRC

** url actions
*** sej/insert-url
    - from jcs (Irreal) blog to copy url from safari and paste at point
#+BEGIN_SRC emacs-lisp
     (when sys/macp
       (defun sej/retrieve-url ()
         "Retrieve the URL of the current Safari page as a string."
         (org-trim (shell-command-to-string
                    "osascript -e 'tell application \"Safari\" to return URL of document 1'")))
       (defun sej/insert-url ()
         "Insert URL of current browser page into Emacs buffer."
         (interactive)
         (insert (sej/retrieve-url))))
#+END_SRC

*** ace-link
    - Quickly follow links
    #+BEGIN_SRC emacs-lisp
      (use-package ace-link
        :bind (:map sej-mode-map
                    ("H-o" . ace-link-addr))
        ;; :hook (sej/after-init . ace-link-setup-default)
        )
    #+END_SRC

*** browse-url
    - Pass a URL to a WWW browser
    #+BEGIN_SRC emacs-lisp
      (use-package browse-url
        :ensure nil
        :defines dired-mode-map
        :bind (:map sej-mode-map
                    ("C-c C-z ." . browse-url-at-point)
                    ("C-c C-z b" . browse-url-of-buffer)
                    ("C-c C-z r" . browse-url-of-region)
                    ("C-c C-z u" . browse-url)
                    ("C-c C-z v" . browse-url-of-file))
        :init
        (with-eval-after-load 'dired
          (bind-key "C-c C-z f" #'browse-url-of-file dired-mode-map)))
    #+END_SRC

*** goto-addr
    - Click to browse URL or to send to e-mail address
    #+BEGIN_SRC emacs-lisp
      (use-package goto-addr
        :ensure nil
        :hook ((text-mode . goto-address-mode)
               (prog-mode . goto-address-prog-mode)))
    #+END_SRC

** un-catagorized
*** general edit settings
    #+BEGIN_SRC emacs-lisp
      ;; Set the default formatting styles for various C based modes
      (setq c-default-style
            '((awk-mode . "awk")
              (other . "java")))

      ;; yes and no settings
      (defalias 'yes-or-no-p 'y-or-n-p)

      ;; do/don't indicate empty or end of a buffer
      (setq-default indicate-empty-lines t)
      (setq-default indicate-buffer-boundaries t)
      (setq-default show-trailing-whitespace nil)
      (setq-default mode-require-final-newline nil)
      (setq-default require-final-newline nil)

      ;;keep cursor at same position when scrolling
      (setq scroll-preserve-screen-position 1)
      (setq scroll-margin 3)

      ;; each line of text gets one line on the screen
      (setq-default truncate-lines 1)
      (setq font-lock-maximum-decoration t
            truncate-partial-width-windows 1)

      ;; ignore case when searching
      (setq-default case-fold-search 1)

      ;; add a new line when going to the next line
      (setq next-line-add-newlines t)

      ;;(transient-mark-mode t)
      (setq select-enable-clipboard t)

      ;; Automatically update unmodified buffers whose files have changed.
      (global-auto-revert-mode 1)

      ;; Make compilation buffers scroll to follow the output, but stop scrolling
      ;; at the first error.
      (setq compilation-scroll-output 'first-error)

      ;; echo keystrokes ; no dialog boxes ; visable bell ; highlight parens
      (setq echo-keystrokes 0.1)
      (setq use-dialog-box nil
            visible-bell t)
      (show-paren-mode t)

      ;; Add proper word wrapping
      (global-visual-line-mode t)
      (setq line-move-visual t)

      (setq-default backup-directory-alist
                    '(("." . ".saves")))    ; don't litter my fs tree

      (setq vc-make-backup-files t
            backup-by-copying t      ; don't clobber symlinks
            backup-directory-alist
            '(("." . ".saves"))    ; don't litter my fs tree
            delete-old-versions t
            kept-new-versions 6
            kept-old-versions 2
            version-control t)       ; use versioned backups

      ;; remove kill buffer with live process prompt
      (setq kill-buffer-query-functions
            (remq 'process-kill-buffer-query-function
                  kill-buffer-query-functions))

      (setq-default kill-read-only-ok t)

      ;; hide mouse while typing
      (setq make-pointer-invisible t)

      ;; color codes
      (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
      (add-to-list 'comint-output-filter-functions 'ansi-color-process-output)

      ;; Save whatever’s in the current (system) clipboard before
      ;; replacing it with the Emacs’ text.
      ;; https://github.com/dakrone/eos/blob/master/eos.org
      (setq save-interprogram-paste-before-kill t)

      ;; org-mode: Don't ruin S-arrow to switch windows please (use M-+ and M-- instead to toggle)
      (setq org-replace-disputed-keys t)

      ;; Fontify org-mode code blocks
      (setq org-src-fontify-natively t)

      ;; UTF-8 please
      (setq locale-coding-system 'utf-8) ; pretty
      (set-terminal-coding-system 'utf-8) ; pretty
      (set-keyboard-coding-system 'utf-8) ; pretty
      (set-selection-coding-system 'utf-8) ; please
      (prefer-coding-system 'utf-8) ; with sugar on top


      ;; uniquify settings
      (setq uniquify-buffer-name-style 'post-forward-angle-brackets) ; Show path if names are same
      (setq uniquify-separator " • ")
      (setq uniquify-after-kill-buffer-p t)
      (setq uniquify-ignore-buffers-re "^\\*")

      (setq adaptive-fill-regexp "[ t]+|[ t]*([0-9]+.|*+)[ t]*")
      (setq adaptive-fill-first-line-regexp "^* *$")
      (setq delete-by-moving-to-trash t)         ; Deleting files go to OS's trash folder
      (if sys/macp (setq trash-directory "~/.Trash"))
      (setq make-backup-files nil)               ; Forbide to make backup files
      (setq auto-save-default nil)               ; Disable auto save
      (add-hook 'before-save-hook 'time-stamp)   ; update time-stamps in files

      ;; When popping the mark, continue popping until the cursor actually moves
      ;; Also, if the last command was a copy - skip past all the expand-region cruft.
      (defadvice pop-to-mark-command (around ensure-new-position activate)
        (let ((p (point)))
          (when (eq last-command 'save-region-or-current-line)
            ad-do-it
            ad-do-it
            ad-do-it)
          (dotimes (i 10)
            (when (= p (point)) ad-do-it))))

      (setq set-mark-command-repeat-pop t)

      (setq-default major-mode 'text-mode)

      ;; Sentences do not need double spaces to end. Period.

      (setq sentence-end-double-space nil)
    #+END_SRC

*** undo-tree
    - Treat undo history as a tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish
    :defer 10
    :config (global-undo-tree-mode)
    :bind (:map sej-mode-map
                ("C-/" . undo-tree-undo)
                ("C-?" . undo-tree-redo)
                ("C-x u" . undo-tree-visualize)
                ("C-x r u" . undo-tree-save-state-to-register)
                ("C-x r U" . undo-tree-save-state-from-register))
    :init (setq undo-tree-visualizer-timestamps t
                undo-tree-visualizer-diff t
                undo-tree-enable-undo-in-region nil
                undo-tree-auto-save-history nil
                undo-tree-history-directory-alist
                `(("." . ,(locate-user-emacs-file "undo-tree-hist/"))))  )
#+END_SRC

*** iedit
    - Edit multiple regions in the same way simultaneously
#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :defines desktop-minor-mode-table
    :bind ((:map sej-mode-map
                 ("A-;" . iedit-mode)
                 ("C-x r RET" . iedit-rectangle-mode))
           (:map isearch-mode-map ("A-;" . iedit-mode-from-isearch))
           (:map esc-map ("A-;" . iedit-execute-last-modification))
           (:map help-map ("A-;" . iedit-mode-toggle-on-function)))
    :config
    ;; Avoid restoring `iedit-mode'
    (with-eval-after-load 'desktop
      (add-to-list 'desktop-minor-mode-table
                   '(iedit-mode nil))))
#+END_SRC

*** multiple cursors
    - Multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind ((:map sej-mode-map
                 ("C-S-c C-S-c"   . mc/edit-lines)
                 ("C->"           . mc/mark-next-like-this)
                 ("C-<"           . mc/mark-previous-like-this)
                 ("C-c C-<"       . mc/mark-all-like-this)
                 ("C-M->"         . mc/skip-to-next-like-this)
                 ("C-M-<"         . mc/skip-to-previous-like-this)
                 ("s-<mouse-1>"   . mc/add-cursor-on-click)
                 ("C-S-<mouse-1>" . mc/add-cursor-on-click))
           (:map mc/keymap
                 ("C-|" . mc/vertical-align-with-space))))
#+END_SRC

*** hydra
    - Make bindings that stick around
#+BEGIN_SRC emacs-lisp
  (use-package hydra)
#+END_SRC

*** imenu
    - Framework for mode-specific buffer indexes
#+BEGIN_SRC emacs-lisp
  (use-package imenu
    :ensure nil
    :bind (:map sej-mode-map
                ("C-." . imenu)))
#+END_SRC

*** origami
    - Flexible text folding
#+BEGIN_SRC emacs-lisp
  (use-package origami
    :hook (prog-mode . origami-mode)
    :init (setq origami-show-fold-header t)
    :bind (:map origami-mode-map
                ("A-`" . hydra-origami/body))
    ;; DONE conflict with sej/push-mark-no-activate
    :config
    (face-spec-reset-face 'origami-fold-header-face)

    (when sej-lsp
      ;; Support LSP
      (use-package lsp-origami
        :hook (origami-mode . (lambda ()
                                (if lsp-mode
                                    (lsp-origami-mode))))))

    (defhydra hydra-origami (:color blue :hint none)
      "
  ^Node^                     ^Other^
  ^^─────────────────────────^^────────────
  _:_: toggle recursively    _u_: undo
  _a_: toggle all            _r_: redo
  _t_: toggle current        _R_: reset
  _o_: only show current
  "
      (":" origami-recursively-toggle-node)
      ("a" origami-toggle-all-nodes)
      ("t" origami-toggle-node)
      ("o" origami-show-only-node)
      ("u" origami-undo)
      ("r" origami-redo)
      ("R" origami-reset)))
#+END_SRC

*** comment-dwim-2
    - An all-in-one comment command to rule them all
#+BEGIN_SRC emacs-lisp
  (use-package comment-dwim-2
    :bind ([remap comment-dwim] . comment-dwim-2)) ; C-; and  M-;
#+END_SRC

*** ediff
    A saner ediff
#+BEGIN_SRC emacs-lisp
  (use-package ediff
    :ensure nil
    :hook(;; show org ediffs unfolded
          (ediff-prepare-buffer . outline-show-all)
          ;; restore window layout when done
          (ediff-quit . winner-undo))
    :config
    (setq ediff-diff-options "-w")
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-merge-split-window-function 'split-window-horizontally))
#+END_SRC

*** elec-pair
    - Automatic parenthesis pairing
#+BEGIN_SRC emacs-lisp
  (use-package elec-pair
    :ensure nil
    :hook (prog-mode . electric-pair-mode)
    :init (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
    :config
    (electric-layout-mode t)
    (electric-indent-mode t)
    ;; Ignore electric indentation for python and yaml
    (defun electric-indent-ignore-mode (char)
      "Ignore electric indentation for 'python-mode'.  CHAR is input character."
      (if (or (equal major-mode 'python-mode)
              (equal major-mode 'yaml-mode))
          'no-indent
        nil))
    (add-hook 'electric-indent-functions 'electric-indent-ignore-mode))
#+END_SRC
** highlighting faces fonts
*** hl-line
    - Highlight the current line
#+BEGIN_SRC emacs-lisp
(use-package hl-line
  :ensure nil
  :hook (sej/after-init . global-hl-line-mode))
#+END_SRC

*** symbol-overlay
    - Highlight symbols
#+BEGIN_SRC emacs-lisp
(use-package symbol-overlay
  :diminish
  :defines iedit-mode
  :commands (symbol-overlay-get-symbol
             symbol-overlay-assoc
             symbol-overlay-get-list
             symbol-overlay-jump-call)
  :bind (("M-i" . symbol-overlay-put)
         ("M-n" . symbol-overlay-jump-next)
         ("M-p" . symbol-overlay-jump-prev)
         ("M-N" . symbol-overlay-switch-forward)
         ("M-P" . symbol-overlay-switch-backward)
         ("M-C" . symbol-overlay-remove-all)
         ([M-f3] . symbol-overlay-remove-all))
  :hook ((prog-mode . symbol-overlay-mode)
         (iedit-mode . (lambda () (symbol-overlay-mode -1)))
         (iedit-mode-end . symbol-overlay-mode)))
#+END_SRC

*** dimmer
    - minor mode that indicates currently active buffer by dimming the faces in others
#+BEGIN_SRC emacs-lisp
(use-package dimmer
  :defer 5
  :config
  (setq dimmer-fraction 0.20)
  (dimmer-mode))
#+END_SRC

*** highlight-numbers
    - hightlight-numbers in a special way
#+BEGIN_SRC emacs-lisp
(use-package highlight-numbers
  :hook (prog-mode . highlight-numbers-mode))
#+END_SRC

*** highlight-indent-guides
    - Highlight indentations
#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (use-package highlight-indent-guides
      :diminish
      :hook (prog-mode . (lambda ()
                           ;; WORKAROUND:Fix the issue of not displaying plots
                           ;; @see https://github.com/DarthFennec/highlight-indent-guides/issues/55
                           (unless (eq major-mode 'ein:notebook-multilang-mode)
                             (highlight-indent-guides-mode 1))))
      :config
      (setq highlight-indent-guides-method 'character)
      (setq highlight-indent-guides-responsive 'top)

      ;; Disable `highlight-indent-guides-mode' in `swiper'
      ;; https://github.com/DarthFennec/highlight-indent-guides/issues/40
      (with-eval-after-load 'ivy
        (defadvice ivy-cleanup-string (after my-ivy-cleanup-hig activate)
          (let ((pos 0) (next 0) (limit (length str)) (prop 'highlight-indent-guides-prop))
            (while (and pos next)
              (setq next (text-property-not-all pos limit prop nil str))
              (when next
                (setq pos (text-property-any next limit prop nil str))
                (ignore-errors
                  (remove-text-properties next pos '(display nil face nil) str)))))))))
#+END_SRC

*** rainbow-mode
    - Colorize color names in buffers
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :diminish
    :hook (prog-mode . rainbow-mode)
    :config
    ;; HACK: Use overlay instead of text properties to override `hl-line' faces.
    ;; @see https://emacs.stackexchange.com/questions/36420
    (defun my-rainbow-colorize-match (color &optional match)
      (let* ((match (or match 0))
             (ov (make-overlay (match-beginning match) (match-end match))))
        (overlay-put ov
                     'face `((:foreground ,(if (> 0.5 (rainbow-x-color-luminance color))
                                               "white" "black"))
                             (:background ,color)))
        (overlay-put ov 'ovrainbow t)))
    (advice-add #'rainbow-colorize-match :override #'my-rainbow-colorize-match)

    (defun my-rainbow-clear-overlays ()
      (remove-overlays (point-min) (point-max) 'ovrainbow t))
    (advice-add #'rainbow-turn-off :after #'my-rainbow-clear-overlays))
#+END_SRC

*** hl-todo
    - Highlight TODO and similar keywords in comments and strings
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :custom-face (hl-todo ((t (:box t :inherit))))
    :bind (:map hl-todo-mode-map
                ([C-f3] . hl-todo-occur)
                ("C-c t o" . hl-todo-occur)
                ("H-o" . hl-todo-occur)
                ("C-c t p" . hl-todo-previous)
                ("H-p" . hl-todo-previous)
                ("C-c t n" . hl-todo-next)
                ("H-n" . hl-todo-next))
    :hook (sej/after-init . global-hl-todo-mode)
    :config
    (dolist (keyword '("BUG" "DEFECT" "ISSUE"))
      (cl-pushnew `(,keyword . ,(face-foreground 'error)) hl-todo-keyword-faces))
    (dolist (keyword '("WORKAROUND" "HACK" "TRICK"))
      (cl-pushnew `(,keyword . ,(face-foreground 'warning)) hl-todo-keyword-faces)))
#+END_SRC

*** diff-hl
    - Highlight uncommitted changes
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :defines (diff-hl-margin-symbols-alist desktop-minor-mode-table)
    :commands diff-hl-magit-post-refresh
    :custom-face
    (diff-hl-change ((t (:background "#46D9FF"))))
    (diff-hl-delete ((t (:background "#ff6c6b"))))
    (diff-hl-insert ((t (:background "#98be65"))))
    :bind (:map diff-hl-command-map
                ("SPC" . diff-hl-mark-hunk))
    :hook ((after-init . global-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode))
    :config
    ;; Highlight on-the-fly
    (diff-hl-flydiff-mode 1)

    ;; Set fringe style
    (setq-default fringes-outside-margins t)
    (setq diff-hl-draw-borders nil)
    (if sys/mac-x-p (set-fringe-mode '(4 . 8)))

    (unless (display-graphic-p)
      (setq diff-hl-margin-symbols-alist
            '((insert . " ") (delete . " ") (change . " ")
              (unknown . " ") (ignored . " ")))
      ;; Fall back to the display margin since the fringe is unavailable in tty
      (diff-hl-margin-mode 1)
      ;; Avoid restoring `diff-hl-margin-mode'
      (with-eval-after-load 'desktop
        (add-to-list 'desktop-minor-mode-table
                     '(diff-hl-margin-mode nil))))

    ;; Integration with magit
    (with-eval-after-load 'magit
      (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)))
#+END_SRC

*** volatile-highlights
    - Highlight some buffer region operations
#+BEGIN_SRC emacs-lisp
  (use-package volatile-highlights
    :diminish
    :hook (sej/after-init . volatile-highlights-mode))
#+END_SRC

*** whitespace
    - Visualize TAB, (HARD) SPACE, NEWLINE
#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :ensure nil
    :diminish
    :hook ((prog-mode outline-mode conf-mode) . whitespace-mode)
    :config
    (setq whitespace-line-column fill-column) ;; limit line length
    ;; automatically clean up bad whitespace
    (setq whitespace-action '(auto-cleanup))
    ;; only show bad whitespace
    (setq whitespace-style '(face
                             trailing space-before-tab
                             indentation empty space-after-tab))

    (with-eval-after-load 'popup
      ;; advice for whitespace-mode conflict with popup
      (defvar my-prev-whitespace-mode nil)
      (make-local-variable 'my-prev-whitespace-mode)

      (defadvice popup-draw (before my-turn-off-whitespace activate compile)
        "Turn off whitespace mode before showing autocomplete box."
        (if whitespace-mode
            (progn
              (setq my-prev-whitespace-mode t)
              (whitespace-mode -1))
          (setq my-prev-whitespace-mode nil)))

      (defadvice popup-delete (after my-restore-whitespace activate compile)
        "Restore previous whitespace mode when deleting autocomplete box."
        (if my-prev-whitespace-mode
            (whitespace-mode 1)))))
#+END_SRC

*** pulse
    - Pulse current line
#+BEGIN_SRC emacs-lisp
  (use-package pulse
    :ensure nil
    :preface
    (defun my-pulse-momentary-line (&rest _)
      "Pulse the current line."
      (pulse-momentary-highlight-one-line (point) 'next-error))

    (defun my-pulse-momentary (&rest _)
      "Pulse the current line."
      (if (fboundp 'xref-pulse-momentarily)
          (xref-pulse-momentarily)
        (my-pulse-momentary-line)))

    (defun my-recenter-and-pulse(&rest _)
      "Recenter and pulse the current line."
      (recenter)
      (my-pulse-momentary))

    (defun my-recenter-and-pulse-line (&rest _)
      "Recenter and pulse the current line."
      (recenter)
      (my-pulse-momentary-line))
    :hook (((dumb-jump-after-jump
             imenu-after-jump) . my-recenter-and-pulse)
           ((bookmark-after-jump
             magit-diff-visit-file
             next-error) . my-recenter-and-pulse-line))
    :init
    (dolist (cmd '(recenter-top-bottom
                   other-window ace-window windmove-do-window-select
                   pager-page-down pager-page-up
                   symbol-overlay-basic-jump))
      (advice-add cmd :after #'my-pulse-momentary-line))
    (dolist (cmd '(pop-to-mark-command
                   pop-global-mark
                   goto-last-change))
      (advice-add cmd :after #'my-recenter-and-pulse)))
#+END_SRC

*** rainbow-delimiters
    - rainbow-delimiters-mode - multicoloured brackets
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :diminish rainbow-delimiters-mode
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (require 'cl-lib)
    (require 'color)
    (cl-loop
     for index from 1 to rainbow-delimiters-max-face-count
     do
     (let ((face (intern (format "rainbow-delimiters-depth-%d-face" index))))
       (cl-callf color-saturate-name (face-foreground face) 30)))
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground 'unspecified
                        :inherit 'error
                        :strike-through t))
#+END_SRC

*** mic-paren
    - show parens even off screen
#+BEGIN_SRC emacs-lisp
  (use-package mic-paren
    :hook (prog-mode . paren-activate)
    :config
    (setq paren-highlight-offscreen t))
#+END_SRC
